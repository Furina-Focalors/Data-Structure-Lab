# Data-Structure-Lab
《数据结构》课程实验

## Lab 1
### Q1
#### 问题描述
给定⻓度为 n 且⽆重复元素的有序数组 nums ，以及⽬标值 t 。在 nums 中找到 t ，并返回其索引（从 0 开始）。如果 t 不存在于 nums 中，返回它将会被按顺序插⼊的位置。算法时间复杂度应为 O(logn)。
分析上述题目要求可知，该问题要求一个时间复杂度为O（logn）的查找算法，查找给定有序数组中的目标值，若目标值不存在则返回插入位置。

#### 算法思想
考虑到题目对算法的时间复杂度有给定要求，这里选择二分查找算法以匹配题目要求，用low, mid, high三个值进行二分。此外，为尽可能减少时间成本，考虑到数组有序，先对传入目标值大小进行判断，若小于数组最小值则直接返回0，若大于数组最大值则直接返回数组长度-1。若不满足上述条件且目标值不存在，则返回mid的值即为应插入的位置。

考虑到c++中在函数体内获取任意输入的数组长度较为麻烦（该问题将在下一题中详细描述），故本题使用c++ vector代替内置数组，便于获取数组长度。

#### 功能函数
```cpp
int search(vector<int>arr, int target);
```
该函数用于二分查找实现题目功能，其中arr为用户输入的有序数组，target为目标值。

### Q2
#### 问题描述
给定两个整数数组 a 和 b，⻓度分别为 n 和 m。如果 0 ≤ i &lt; j, a i = b i，存在 j 使得 aj&lt;bj,则称 a &lt; b。或者，对任意 i (0 ≤ i &lt; n ), 有 a i = b i，且 n &lt; m，则称 a &lt;b。对任意 i (0 ≤ i &lt; n ), 有 a i = b i，且 n = m，则称 a=b 。

分析上述内容可知该题目要求设计一个算法对两个整数数组判断大小，需要判断数组元素之间的大小关系。

#### 算法思想
观察a&lt;b和a=b的条件知，n&lt;=m一定成立。故先判断两个数组的长度n和m，当n&gt;m时两个结果都不成立。此外，两个表达式都要求数组中下标小于j的元素均对应相等，因此在确定j的值时利用for循环，当查找到第一组不等的元素时跳出循环，该值即为可能的j值。
最后，根据题目要求，判断j, n, m的大小关系和a[j]，b[j]的大小关系即可得到对应数组的大小关系。

#### 功能函数
```cpp
void arrCompare(int* a, int aSize, int* b, int bSize);
```
该函数用于实现1要求的比较功能。其中a，b为传入的数组，aSize与bSize为两个数组的长度。

### Q3
#### 问题描述
矩阵转置，重写 FastTranspose （程序 2.11），要求只⽤⼀个数组保存 RowSize 和 RowStart 的信息。时间复杂度 O(terms+cols)。

分析上述内容，要求优化稀疏矩阵转置的函数，减少一个临时数组，同时保持时间复杂度不变（原程序的时间复杂度即为O(terms+cols)）。

#### 算法思想
分析原先代码可知，该函数声明了两个临时数组RowSize和RowStart，前者用于保存对应行的元素个数，后者用于保存对应行在转置后应存储的起始位置。由于上述两个数组的长度都为cols（即原矩阵的列数），因此只要创建一个长度为2*cols的数组，前半存储RowSize，后半存储RowStart，即可解决问题。

#### 功能函数
```cpp
void print();
```
该函数仅用于显示矩阵各非零元素的信息，包括行、列、值。
```cpp
SparseMatrix FastTransposeUpdated();
```
该函数为优化后的矩阵转置函数，用于实现题目要求的转置功能。

## Lab 2
### Q1
#### 问题描述
给定一个字符串，统计每个字符出现的次数。

分析上述内容可知需要一组临时变量暂存字符出现的次数，然后进行输出。

#### 算法思想
该实验要求统计每个字符出现的次数，因此可以遍历字符串，用一个数组统计每个字符出现的次数，之后根据数组的信息输出统计结果。假设字符串的内容仅包含ASCII码中出现的所有可显示字符，故只需要一个长度为95的int类型数组用于记录每个字符的出现次数。之后只需对每个非零值作输出判定即可
#### 功能函数
```cpp
void calculate(string str);
```
该函数用于实现对给定字符串str的遍历，记录每个字符的出现次数并输出统计结果。

### Q2
#### 问题描述
给定一个长度为 n 的数组 nums，对其进行原地反转（要求空间复杂度 O（1））。反转的意思是 nums[i]中保存原来 nums[n-1-i]的值。

分析上述题目要求可知，该实验要求反转数组的内容，且由于要求空间复杂度O(1)，应直接对原数组进行反转而不能声明另一个等长的临时数组。

#### 算法思想
交换数组对应元素时，如将第一个元素与最后一个元素交换，则不再需要对最后一个元素进行操作。故只需对数组的前一半元素进行交换操作。
#### 功能函数
```cpp
void inverse(int* nums, int length);
```
该函数用于原地反转长度为length的int类型数组nums。

### Q3
#### 问题描述
对于多项式计算，有公式 1：𝑓1(𝑥) = 𝑎0 + 𝑎1𝑥 + ⋯ + 𝑎𝑛−1𝑥𝑛−1 + 𝑎𝑛𝑥𝑛
公式 2：𝑓2(𝑥) = 𝑎0 + 𝑥(𝑎1 + 𝑥(…(𝑎𝑛−1 + 𝑥(𝑎𝑛)) … ))
其中，系数𝑎0, 𝑎1, … , 𝑎𝑛, (0 ≤ 𝑎𝑛 ≤ 9，𝑖 = 0, … , 𝑛)可由伪随机数 rand()获得，采用多项式结构存储。要求对于给定的𝑥，分别采用迭代法和递归法各编写两个函数 F1a、F2a 和 F1b、 F2b，实现两个公式的计算方法。
特别地，若有公式 3𝑓3(𝑥) = 1 + ∑ 𝑥𝑖/𝑖 𝑛𝑖=1
1. 取𝑥 = 1.1，计算𝑓3(𝑥)的值。
2. 当𝑛的取值为{1，5，10，15，20，25，30，35，40，45，50，60，70，80，90，100}时，分别利用 clock()函数，获得四个算法在同一计算机上的运行时间，并给出对比表格。每行代表一个算法，每列为𝑛的一个取值。
3. 将第二问中的表格转为图形可视化表示（如用 Excel、MATLAB、Python matplotlib 等）。
分析上述内容，该实验要求分别用迭代与递归两种方法实现两个公式的计算，并测试其运行时间做成表格。

#### 算法思想
- 公式1迭代实现：循环n+1次，用一个临时变量累加每次的计算结果（对应系数*变量的i次方）
- 公式1递归实现：结束条件为当n=0时，仅返回系数a0的值，递归时应返回对应次数为n的项的值𝑎𝑛𝑥𝑛并使次数减去1传入自身函数进行递归。
- 公式2迭代实现：根据公式，将结果的初始值设定为an，每次循环使结果乘以变量值并加上an-1即可。
- 公式2递归实现：结束条件为当n=0时输出最后一项的系数值（即最中间括号的值），递归时用前一项的系数加上自变量的值乘以公式中后面所有的括号，而该部分即可以直接调用函数本身。

获取算法的运行时间时，由于单次执行速度过快，故将每个算法执行10^6次以放大执行时间，利用clock()函数获得并进行输出对比。

#### 功能函数
```cpp
void Polynomial::print()const;
```
该函数仅用于输出多项式的表达式。
```cpp
float Polynomial::F1a(float f);
```
该函数为公式1的迭代实现。
```cpp
float Polynomial::F1b(float f,int n);
```
该函数为公式1的递归实现，其中，n=degree时实现公式1。
```cpp
float Polynomial::F2a(float f);
```
该函数为公式2的迭代实现。
```cpp
float Polynomial::F2b(float f,int n);
```
该函数为公式2的递归实现，其中，n=degree时实现公式2.


### Extra Exercise
#### 问题描述
给定一个字符串 s，找到 s 中最长的回文字串。回文串就是正着读和反着读都一样的字符串。

题目要求找出最长的回文字串，需要对字符串中每个位置（或多个位置）进行判断，同时，需要考虑到出现等长回文字串的情况。

#### 算法思想
根据以上思想，首先设计一个算法，输入给定字符，输出该字符为中心或该字符与相邻字符（如果相同）为中心的最长回文字串；之后利用该算法遍历原字符串得到长度最长的回文字串。

普遍来说，越靠近原字符串中心的位置，越有可能出现长度较大的回文字串。或者说，当我们已经找到了长度为a的回文字串，那么剩余的位置中，字符串中前a/2个字符与后a/2个字符为中心一定不可能出现长度大于a的回文字串。因此，该算法从传入字符串的中间字符开始对比。为了尽可能地先判断中心字符出现在原字符串中靠近中心位置的回文字串，该算法对传入字符串的中心字符判断顺序为：mid/2，mid/2-1，mid/2+1，mid/2-2，mid/2+2，…，其中mid=s.length()/2。

最后，该算法还应处理长度相同的问题。这里约定：若原字符串中出现多个长度相同的回文字串，函数返回原字符串中较为靠前的那个回文字串。

#### 功能函数
```cpp
string digitMax(string s,int mid);
```
该函数用于对给定字符串s，返回以其下标为mid的字符为中心，且长度最长的回文字串。
```cpp
string longestPalindrome(string s);
```
该函数用于实现对给定字符串s，返回其中长度最长的回文字串，若有多个长度相同，则输出较为靠前的那个。其中调用了函数1，对原字符串的多个位置进行判断。

## Lab 3
### Q1
#### 问题描述
给定一个只包含’(‘, ‘)’, ‘[‘, ‘]’, ‘{‘, ‘}’的字符串 S，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。

由描述可知，需要设计一个函数对三种括号进行匹配，当左右括号不匹配或顺序不正确的时返回0.

#### 算法思想
当字符串中出现右括号时，若该字符串合法，则一定满足下述条件：
1. 在该右括号之前出现过类型相同的左括号
2. 在这一对左右括号之间没有单独的左或右括号

因此考虑用一个临时栈解决问题。将字符串的内容依次入栈，若入栈的是右括号则将栈内下一个元素退栈并进行判断，若和右括号匹配则“消去”这一对括号，否则字符串无效。为了判断栈内是否存在单独的右括号，需在匹配时检测栈是否为空，若为空则右括号是单独出现的；还要在最后对栈判断空，若非空则表明存在单独的左括号。

#### 功能函数
```cpp
int isValid(string s);
```
该函数用于实现对输入字符串s判断是否有效。若有效则函数返回1，无效则返回0.

### Q2
#### 问题描述
请仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push, pop, peek, empty）

该实验要求用LIFO的栈结构实现FIFO的队列，因此需要设计算法获取栈底元素。

#### 算法思想
对于判空和入队两个操作，其实现和栈类似，但pop和peek在队列中要求获取栈底元素，故将第二个栈作为临时栈存放上方的所有元素，将栈底元素取出后再将所有元素放回。
#### 功能函数
```cpp
void push(const T& item)
```
该函数用于实现入队，其中T为队列中的元素类型。
```cpp
void pop()
```
该函数用于实现出队。
```cpp
bool empty()const
```
该函数用于判断队列是否为空。
```cpp
T peek()
```
该函数返回队列最前方的元素。

## Lab 4
### Q1
#### 问题描述
输入一个链表，输出该链表中倒数第 k 个节点。从 1 开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6. 这个链表的倒数第 3 个节点是值为 4 的节点。

该问题要求返回链表中倒数第n个节点。考虑到单链表无法直接倒序遍历，获取倒数元素需要的时间资源较多，因此用双向链表进行倒序遍历获得倒数第k个节点。

#### 算法思想
算法设计：利用传入的k和指向直接前驱的左指针lLink直接逆序查找第k个节点。需首先判断传入的k是否合法。

算法优化：若k合法的情况下，判断倒数第k个元素在链表的前一半还是后一半，若在前一半则正序遍历，后一半则逆序遍历，可减少执行时间（不减少时间复杂度）。

#### 功能函数
```cpp
bool Insert(int i, T x)
```
该函数实现链表节点的插入，成功返回true，否则返回false。其中i为插入位置（下标），i=0代表头结点，x为数据。
```cpp
bool Delete(int i, T& x)
```
该函数实现链表节点的删除，成功返回true，否则返回false。其中i为插入位置（下标），x用于接收删除节点的数据。
```cpp
void print()const
```
该函数用于打印整个链表。
```cpp
int Length()const
```
该函数返回链表长度。
```cpp
DoublyNode<T>* bottomK(int k)const
```
该函数返回链表倒数第k个元素，实现实验要求。

### Q2
#### 问题描述
完成反转函数，输入一个链表的头节点，反转该链表并输出反转后的链表。你需要反转链表本身，而不是反转值。

类似实验一，单链表实现逆序遍历较为复杂，故此处也选择双向链表。该实验要求反转链表本身，改变元素之间的关系而非元素的数据。

#### 算法思想
由于是双向链表，可以方便地表示每个节点的直接前驱和直接后继，即上一个和下一个节点。因此，只要将每个节点的下一个节点设置为其原本的上一个节点，就实现了链表的翻转。因此对于每个节点，只要将其左右指针的指向交换，即可实现链表反转。特别地，若链表为空，则直接返回。
#### 功能函数
该实验中包含实验一内函数1至函数4，作用完全相同.
```cpp
void inverse()
```
该函数用于实现链表的翻转。根据题目要求，翻转后用print()函数再将链表进行输出。

### Q3
#### 问题描述
给你两个单链表的头节点 headA 和 headB，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null。请使用空间复杂度较小的算法。

单链表相交表示从某个节点起两个链表共享同一列节点。因此需要判断两个链表是否包含同一列节点。

#### 算法思想
如果两个链表相交，那么从起始节点开始，两个链表的节点完全相同。因此，链表相交的部分长度一定相同，且一定包含最后一个节点。因此，若相交的起始节点是链表A的倒数第k个节点，那么它一定也是链表B的倒数第k个节点。由于是单链表，故设置一个标识变量sign，记录连续相同节点的个数，根据以上分析知sign=k。又由于相交部分长度相同，需要先对齐两个链表，即将较长链表的遍历指针往后移动，直至从该指针开始到最后节点的长度等于较短链表的长度。
#### 功能函数
```cpp
bool Insert(int i, T x)
```
该函数用于实现链表节点的插入，成功返回true，失败返回false。其中i为下标，x为元素值。
```cpp
bool Delete(int i, T& x)
```
该函数用于实现链表节点的删除，成功返回true，失败返回false。其中i为下标，x用于接收被删除节点的数据。
```cpp
void print()const
```
该函数用于打印整个链表。
```cpp
ListNode<T>* intersectionNode(List<T> target)const
```
该函数检查链表与传入的链表target是否相交，若相交返回相交的起始节点，否则返回nullptr。
```cpp
void linkTo(List lis, int i)
```
该函数将链表的最后一个节点的link指向链表lis中下标为i的节点，即使链表与lis相交，起始节点为lis[i]。

### Q4&Extra Lab
#### 问题描述
题目四：给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。

附加题：给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。算法的空间复杂度为 O(1)，不允许用额外空间存储整个链表，可以使用几个指针变量。

题目四要求判断链表是否有环，若成环则不存在link值为nullptr的节点，因此无法通过传统方式遍历，需要另外设计算法。同理，附加题要求判断入环节点，在上题基础之上要获取入环节点，也需要另外设计算法寻找该节点。

#### 算法思想
由于两题的难点在于如果存在环，则传统的遍历方法（判断link是否为空指针）会形成死循环。因此，设计两种解决方案如下：
1. 给链表添加一个int类型的数据成员length，用于存储链表的长度，该值在执行插入动作后自增，执行删除动作后自减。这样一来，无论链表是否有环，确定其长度非常容易，因此可以精确地遍历链表。如果链表成环，则一定存在某个节点，该节点被两个节点的link指向。换言之，按照长度进行遍历后，若最后一个节点的link非空，则一定指向了原链表中的某个节点，即存在环。而其指向的节点即为入环节点。
2. 更一般地，若不设置额外的数据成员，则可以用快慢指针的方法实现：快指针每次移动2位，慢指针每次移动1位。若链表中无环，快指针一定会先到达链表的尾节点后结束，否则快指针会因为环的存在回到链表中某个位置，并最终与慢指针相遇。通过该方法可以判断链表中有无环。更进一步，相遇后将快指针返回头结点，接下来使两个指针每次移动1位，再次相遇的节点即为入环节点。

#### 功能函数
```cpp
bool Insert(int i, T x)
```cpp
该函数用于实现链表节点的插入，成功返回true，失败返回false。其中i为下标，x为元素值。
```cpp
bool Delete(int i, T& x)
```
该函数用于实现链表节点的删除，成功返回true，失败返回false。其中i为下标，x用于接收被删除节点的数据。
```cpp
void print()const
```
该函数用于打印整个链表。
```cpp
void ringTo(int i)
```
该函数用于将一个不含有环的单链表的尾节点link指针指向下标为i的元素，即成环。
```cpp
bool isRing()const
```
该函数基于链表长度判断链表中是否有环。
```cpp
bool isRing_noLength()const
```
该函数基于快慢指针判断链表中是否有环。
```cpp
ListNode<T>* ringStart()const
```
该函数基于链表长度返回环链表的入环节点，若链表中没有环，返回nullptr。
```cpp
ListNode<T>* ringStart_noLength()const
```
该函数基于快慢指针返回环链表的入环节点，若链表中没有环，返回nullptr。

## Lab 5
### Q1
#### 问题描述
输入一棵二叉树的根节点，求该树的深度。

要求树的深度，需要找到最底层的叶节点，因此需要对树进行遍历。

#### 算法思想
对于树的根节点，其深度等于其左子树的深度和右子树的深度中较大的那一个+1（根），而求左子树和右子树的深度是原问题的子问题，故可以使用递归方法解决该问题。
#### 功能函数
```cpp
bool BuildRoot(T data)
```
该函数用于生成二叉树的根.
```cpp
bool InsertChild(TreeNode<T>* parent, int lr, T data)
```
该函数用于对节点parent插入左或右孩子，其中lr==0代表左，lr==1代表右，data为子节点的数据.
```cpp
int getDepth(TreeNode<T>* root)const
```
该函数用于对给定的节点作为根节点，返回该根节点下树的最大深度.

### Q2
#### 问题描述
给定一棵二叉树的根节点，将它展开为一个单链表。展开后的单链表应该使用原本的TreeNode，其中right子指针指向链表中下一个节点，而左子指针始终为null。展开后的单链表应该与二叉树前序遍历顺序相同。

题目需要一个原地算法获取二叉树的前序遍历结果。

#### 算法思想
将原问题拆分成两个步骤实现：第一步，获取二叉树的前序遍历，用一个临时栈保存每个根节点的右孩子，之后向左进行遍历；第二步，对前序遍历的结果的左右孩子指针进行操作：将左指针置为nullptr，右指针指向结果中下一个节点，最后一个节点左右指针均为nullptr.
#### 功能函数
```cpp
bool BuildRoot(T data)
```
该函数用于生成二叉树的根.
```cpp
bool InsertChild(TreeNode<T>* parent, int lr, T data)
```
该函数用于对节点parent插入左或右孩子，其中lr==0代表左，lr==1代表右，data为子节点的数据.
```cpp
void treeToChain()
```
该函数用于将二叉树展开为单链表，顺序为其前序遍历顺序

### Q3
#### 问题描述
给定一棵二叉树，翻转二叉树的左右子树，按照前序遍历输出反转后的二叉树各节点值。

题目要求交换每个节点的左右子树，另外需要一个函数实现前序遍历结果的输出。

#### 算法思想
对于根节点，只需要交换其左右指针的指向即可，之后再将其左、右子树翻转，这是原问题的子问题，故使用递归算法自上而下解决原问题。
前序遍历的思想同第二题。

#### 功能函数
```cpp
bool BuildRoot(T data)
```
该函数用于生成二叉树的根.
```cpp
bool InsertChild(TreeNode<T>* parent, int lr, T data)
```
该函数用于对节点parent插入左或右孩子，其中lr==0代表左，lr==1代表右，data为子节点的数据.
```cpp
TreeNode<T>* Invert(TreeNode<T>* node)
```
该函数用于翻转二叉树.
```cpp
void preorderTraverse()const
```
该函数用于前序遍历并按照该顺序输出二叉树.

### Q4
#### 问题描述
给定一棵树的前序遍历和中序遍历，请构造二叉树并返回其根节点。

题目要求根据二叉树的前序和中序遍历构造二叉树。前序遍历的第一个节点为根节点，该节点将中序遍历结果分为其左子树和右子树。算法需要判断并实现上述过程。

#### 算法思想
如上所述，前序遍历的第一个节点为根节点，该节点在中序遍历中将剩余节点分为根的左子树和右子树。可以看出，对根节点执行上述过程后，只需对左子树和右子树执行相同过程即可构造出二叉树，故可以使用递归方法实现。
#### 功能函数
```cpp
bool BuildRoot(T data)
```
该函数用于生成二叉树的根.
```cpp
void preorderTraverse()const
```
该函数用于前序遍历并按照该顺序输出二叉树.
```cpp
vector<T> getPart(vector<T>arr, int start, int end)
```
该函数用于返回arr的部分数组arr[start]至arr[end].
```cpp
TreeNode<T>* constructTree(std::vector<TreeNode<T>*>pre, std::vector<TreeNode<T>*>in)
```
该函数传入两个数组，存放二叉树的前序和中序遍历，返回构造的二叉树的根节点.
```cpp
TreeNode<int>* constructTree(vector<int> preorder, vector<int> inorder`)
```
该函数为前述函数的重载，不同之处是该函数用节点的元素值构造，前述的函数直接传入二叉树的节点.

## Lab 6
### Q1
#### 问题描述
给定一个有n个点m条边的有向图。所有边的长度都是1，点的编号为1-n。请求出1号点到n号点的最短距离，如果从1号点无法达到n号点，则输出-1。

题目要求输出两个给定顶点的最短路径，即设计起点和终点都确定的最短路径算法。

#### 算法思想
对于给定的起点与终点，要求最短路径，可使用广度优先搜索。考虑到所有边的长度都是1，可以省去带权路径长度判断的步骤。使用一个队列逐层遍历给定的图，每遍历一层使长度结果自增。如果遍历完未找到对应的终点，则由BFS的性质可知，该起点与终点之间没有路径，返回-1.
#### 功能函数
```cpp
void addEdge(int fromIndex,int toIndex)
```
该函数用于对有向图添加边.
```cpp
int shortestLength()
```
该函数返回编号为1的顶点到编号为n的顶点之间的最短距离，其中n为顶点总数.

### Q2
#### 问题描述
给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。求最小生成树的树边权重之和，如果最小生成树不存在，则输出“impossible”。（使用Kruskal最小生成树算法）

题目要求使用Kruskal最小生成树算法计算最小生成树的边权重和。关键在于构造最小生成树。

#### 算法思想
Kruskal算法每次选出最小权重的边，将其两个顶点加入一个集合，直到所有顶点被选入该集合或遍历完成。因此，先对给定的图的边按权重从小到大排序，之后采用并查集的Find()功能构造集合，其中判断是否成环的方法是：如果两个顶点在同一集合中，则连接这两个顶点会形成环；判断是否存在最小生成树的方式是：若遍历完成后边数小于原顶点数-1，则由树的性质可知该树的顶点数小于原顶点数，即原无向图不连通，故不存在最小生成树。
#### 功能函数
```cpp
int Find(vector<int>parents, int p)
```
该函数实现并查集的查找功能.
```cpp
int Kruskal(int vertex,vector<edge>edges)
```
该函数输入顶点总数vertex，边数组edges，其中edge为自定义的边类，输出最小生成树的各边权重和，若不存在输出impossible并返回NULL.

### Q3
#### 问题描述
计算机学院大二学生总共有n门课需要选，序号为0到n-1。给定课程之间的先修关系，例如，想要学习课程0，你需要先完成课程1，用一个关系对来表示：（0，1）。求为了学完所有课程的学习顺序。

题目中课程有先修关系，故要想获得课程的学习顺序，需构造有向图并求其拓扑排序.

#### 算法思想
首先需要构造有向图表示课程之间的先修关系，其中当前可以直接学习的课程的特征为入度=0.当该课程学习完毕后，去除与该顶点有关的所有边，之后再次寻找新的入度为0的点.因此，对于一张有向图，首先根据其邻接表获取所有顶点的入度，之后每次寻找入度为0的点，将该点加入结果数组，之后将该顶点指向的所有顶点的入度-1，可以通过访问邻接表实现，直到所有顶点被加入结果数组中.
#### 功能函数
```cpp
void addEdge(int fromIndex,int toIndex)
```
该函数用于对有向图添加边.
```cpp
std::vector<int> courSequence()
```
该函数返回一个int类型的数组，代表课程学习的先后顺序，其中的元素代表课程序号.

### Extra Lab
#### 问题描述
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程equation[i]的长度为4，并采用两种不同的形式之一：“a==b”或”a!=b”。在这里，a和b是小写字母，便是单字母变量名。判断是否存在整数值，能成为方程组的解。

题目要求判断等式能否成立，其关键在于识别相等的元素，将其放入同一个集合.

#### 算法思想
若方程组无解，则一定存在两个变量a与b被同时要求满足a==b与a!=b.故采用并查集构造集合，将所有相等的元素放入同一个集合，这样当一个不等式左右两边的元素在同一个集合中，则该方程组无解.实现过程中，先将所有等式两边的元素加入同一集合，同时暂存所有不等式，再对所有不等式遍历，判断是否存在冲突.
#### 功能函数
```cpp
int Find(int p)
```
该函数为并查集的查找操作函数.
```cpp
void Union(int p, int q)
```
该函数为并查集的合并操作函数.
```cpp
bool hasSolution(vector<string>equation)
```
该函数对传入的string数组（代表方程组）判断是否存在整数解.

## Lab 7
### Q1
#### 问题描述
给定长度为n的整数数列。请使用快速排序对数列按照从小到大进行排序，并将排好序的数列按顺序输出。
#### 算法思想
根据题目要求，实现快速排序算法。主要过程为：选择一个元素，以该元素为基准切分整个数组，将大于该元素的值放在右侧（下标大的一侧），小于该元素的值放在左侧，之后递归调用该方法对左侧和右侧的元素分别排序.特别地，对算法做出以下优化：
1. 当数组规模较小时，采用插入排序效率较高，这里取n=15为分界线，当数组规模小于等于15时改用插入排序；
2. 考虑到快速排序在数组接近有序时时间复杂度显著增加（退化为O(n2)），故在排序之前随机打乱原数组，以最小化这种情况发生的可能性.

#### 功能函数
```cpp
template<class T>
static int partition(std::vector<T>& arr, int lo, int hi)
```
切分函数，将数组分为arr[lo:j],arr[j],arr[j+1:hi+1]，arr[lo:j]的所有元素均不大于arr[j]，arr[j+1:hi+1]中的所有元素均不小于arr[j]；其中arr[lo:j]表示arr中下标从lo到j-1的所有元素.
```cpp
template<class T>
static void qsort(std::vector<T>& arr, int lo, int hi)
```
排序函数，递归地使用切分方法对arr[lo:hi+1]排序
```cpp
template<class T>
static void quick_sort(std::vector<T>& arr)
```
快速排序的实现，其中包含数组打乱与排序两个步骤.

### Q2
#### 问题描述
给定长度为n的整数数列。请使用堆排序算法对数列按照从小到大进行排序，并将排好序的数列按顺序输出。
#### 算法思想
根据题目要求，实现快速排序算法。主要过程为：首先将整个数组建立成最大堆，之后循环地将最大元素（下标为0）交换至最后，并对未排序部分重新调整至堆有序，直到排序完成.
#### 功能函数
```cpp
template<class T>
static void sift_down(std::vector<T>& arr, int k, int max)
```
堆的下沉操作.k为需要调整顺序的元素的下标，用于将数组arr[0:max+1]调整至堆有序（最大堆）.
```cpp
template<class T>
static void heap_sort(std::vector<T>& arr)
```
堆排序的实现.包含建堆、元素交换、重新调整三个步骤.

### Q3
#### 问题描述
给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。快速选择就是在排序过程中，只保留可能出现第k个数的那个区间，舍弃另一个区间.
#### 算法思想
快速选择的过程与快速排序高度相似，但快速选择只需要在切分操作完成后判断切分元素的位置.由于切分的特性，切分元素在排序后的数组中位置是确定的，即可以确定该元素是第几小的元素，与k比较则可以得到所求的第k小的数在切分元素左侧还是右侧，并对相应数组继续切分.
#### 功能函数
```cpp
template<class T>
int partition(std::vector<T>& arr, int lo, int hi)
```
切分，函数功能与快速排序的切分完全相同.
```cpp
int quick_choose(std::vector<int>& arr, int k)
```
快速选择实现，包含切分和选择两个步骤.

### Q4
#### 问题描述
给定一个nxn矩阵matrix，其中每行和每列元素均按升序排序，找到矩阵中第k 小的元素。注意，它是排序后的第k小元素，而不是第k个不同的元素。时间复杂度尽可能低，低于O(n2logn)。
#### 算法思想
将原二维矩阵转化为一维数组，之后对数组排序直接获得第k个元素.
#### 功能函数
```cpp
int kth_smallest(std::vector<std::vector<int>>&mat, int k)
```
查找第k小元素实现，包含矩阵转数组和排序两个步骤.
```cpp
template<class T>
static void heap_sort(std::vector<T>& arr)
```
题目二中的堆排序函数.

### Extra Lab
#### 问题描述
给定一个长度为n的整数数列，请计算数列中的逆序对的数量。逆序对的定义如下：对于数列的第i个和第j个元素，如果满足i&lt;j且a[i]&lt;a[j]，则其为一个逆序对，否则不是。时间复杂度为O(nlogn)。
#### 算法思想
归并排序的归并阶段中，当左侧数组被优先传入结果时，表明该元素比右侧对应元素大，构成逆序，而由于左侧数组是有序的，该元素左边的所有元素也与右侧对应元素构成逆序.故在归并排序的过程中对“左侧元素大”这一情况进行计数，每次的增加量等于左侧数组中第一个元素至出现该情况的元素的个数.
#### 功能函数
```cpp
int reverse_pair_easyfunc(std::vector<int>& arr)
```
测试函数.该函数使用简单方法对每个元素和其右边的所有元素对比，返回逆序对的数量，但该函数的时间复杂度为O(n2)，不符合题目要求，故仅用来判断运行结果.
```cpp
int merge(std::vector<int>& arr, int lo, int mid, int hi)
```
归并函数.将有序数组arr[lo:mid]和arr[mid+1:hi+1]归并成更大的有序数组，返回其中的逆序对数量
```cpp
int min(int a, int b)
```
返回a和b的较小值.
```cpp
int merge_sort_BU(std::vector<int>& arr)
```
自底向上的归并排序.返回值就是arr中逆序对的数量.
```cpp
int reverse_pair(std::vector<int>& arr)
```
该函数仅是为了可读性而设置的，执行过程与上述改写的归并排序完全相同.

## Lab 8
### Q1
#### 问题描述
给定一棵二叉搜索树，请找出其中第k大的节点。
#### 算法思想
二叉搜索树有一个重要的性质，即它的中序遍历是递增的。因此，寻找二叉搜索树中第k大的节点，等价于寻找二叉搜索树的中序遍历的倒数第k个元素。因此，只需要对给定的二叉搜索树进行中序遍历，将结果放入数组，取倒数第k个元素即可。
#### 功能函数
```cpp
std::vector<int> InorderTraversal()const;
```
函数返回二叉搜索树的中序遍历数组.
```cpp
TreeNode* GetRoot()const
```
函数返回二叉树的根节点.
```cpp
int KthLargest(int& k)const
```
函数返回二叉搜索树第k大的元素.

### Q2
#### 问题描述
给定一棵二叉树的根节点root，判断其是否是一棵二叉搜索树。
#### 算法思想
二叉搜索树有一条可以用来判别的性质，即其中序遍历结果是递增的，因此对给定的二叉树只需判断其中序是否是严格递增，即可确定是不是二叉搜索树.
#### 功能函数
```cpp
std::vector<int> InorderTraversal(TreeNode* root)
```
函数接收一颗二叉树的根节点，返回其中序遍历至数组中.
```cpp
bool isBST(TreeNode* root)
```
函数接收一颗二叉树的根节点，判断其是否是二叉搜索树.

